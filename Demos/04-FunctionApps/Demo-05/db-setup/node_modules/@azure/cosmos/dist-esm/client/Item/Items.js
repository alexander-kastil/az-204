import { __awaiter } from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import uuid from "uuid/v4";
import { ChangeFeedIterator } from "../../ChangeFeedIterator";
import { getIdFromLink, getPathFromLink, isResourceValid, ResourceType } from "../../common";
import { extractPartitionKey } from "../../extractPartitionKey";
import { QueryIterator } from "../../queryIterator";
import { Item } from "./Item";
import { ItemResponse } from "./ItemResponse";
/**
 * @ignore
 * @param options
 */
function isChangeFeedOptions(options) {
    const optionsType = typeof options;
    return (options && !(optionsType === "string" || optionsType === "boolean" || optionsType === "number"));
}
/**
 * Operations for creating new items, and reading/querying all items
 *
 * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.
 */
export class Items {
    /**
     * Create an instance of {@link Items} linked to the parent {@link Container}.
     * @param container The parent container.
     * @hidden
     */
    constructor(container, clientContext) {
        this.container = container;
        this.clientContext = clientContext;
    }
    query(query, options = {}) {
        const path = getPathFromLink(this.container.url, ResourceType.item);
        const id = getIdFromLink(this.container.url);
        const fetchFunction = (innerOptions) => {
            return this.clientContext.queryFeed({
                path,
                resourceType: ResourceType.item,
                resourceId: id,
                resultFn: (result) => (result ? result.Documents : []),
                query,
                options: innerOptions
            });
        };
        return new QueryIterator(this.clientContext, query, options, fetchFunction, this.container.url, ResourceType.item);
    }
    readChangeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
        if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
            return this.changeFeed(partitionKeyOrChangeFeedOptions);
        }
        else {
            return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);
        }
    }
    changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
        let partitionKey;
        if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
            partitionKey = undefined;
            changeFeedOptions = partitionKeyOrChangeFeedOptions;
        }
        else if (partitionKeyOrChangeFeedOptions !== undefined &&
            !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
            partitionKey = partitionKeyOrChangeFeedOptions;
        }
        if (!changeFeedOptions) {
            changeFeedOptions = {};
        }
        const path = getPathFromLink(this.container.url, ResourceType.item);
        const id = getIdFromLink(this.container.url);
        return new ChangeFeedIterator(this.clientContext, id, path, partitionKey, changeFeedOptions);
    }
    readAll(options) {
        return this.query("SELECT * from c", options);
    }
    /**
     * Create an item.
     *
     * Any provided type, T, is not necessarily enforced by the SDK.
     * You may get more or less properties and it's up to your logic to enforce it.
     *
     * There is no set schema for JSON items. They may contain any number of custom properties.
     *
     * @param body Represents the body of the item. Can contain any number of user defined properties.
     * @param options Used for modifying the request (for instance, specifying the partition key).
     */
    create(body, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
            const partitionKey = extractPartitionKey(body, partitionKeyDefinition);
            // Generate random document id if the id is missing in the payload and
            // options.disableAutomaticIdGeneration != true
            if ((body.id === undefined || body.id === "") && !options.disableAutomaticIdGeneration) {
                body.id = uuid();
            }
            const err = {};
            if (!isResourceValid(body, err)) {
                throw err;
            }
            const path = getPathFromLink(this.container.url, ResourceType.item);
            const id = getIdFromLink(this.container.url);
            const response = yield this.clientContext.create({
                body,
                path,
                resourceType: ResourceType.item,
                resourceId: id,
                options,
                partitionKey
            });
            const ref = new Item(this.container, response.result.id, partitionKey, this.clientContext);
            return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref);
        });
    }
    upsert(body, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
            const partitionKey = extractPartitionKey(body, partitionKeyDefinition);
            // Generate random document id if the id is missing in the payload and
            // options.disableAutomaticIdGeneration != true
            if ((body.id === undefined || body.id === "") && !options.disableAutomaticIdGeneration) {
                body.id = uuid();
            }
            const err = {};
            if (!isResourceValid(body, err)) {
                throw err;
            }
            const path = getPathFromLink(this.container.url, ResourceType.item);
            const id = getIdFromLink(this.container.url);
            const response = yield this.clientContext.upsert({
                body,
                path,
                resourceType: ResourceType.item,
                resourceId: id,
                options,
                partitionKey
            });
            const ref = new Item(this.container, response.result.id, partitionKey, this.clientContext);
            return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref);
        });
    }
}
//# sourceMappingURL=Items.js.map